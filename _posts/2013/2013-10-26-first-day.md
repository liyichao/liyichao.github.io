---
layout: post
title: "First day"
category: 
tags: []
---
{% include JB/setup %}
#应答系统实现
昨天拿到题目，想了想，实现起来如果直接一点的话，直接一个`bool worker[20]`表示20个客服的忙闲状态就够了，客服告诉系统他离开就置他为忙，但是不计时，如果他本身就是忙的，就拒绝他的离开请求；告诉系统他回来了就置他为闲；接待客户的话就直接从头开始遍历找第一个空闲的，置为忙，同时这个客服的接待时间加1，如果没有找到空闲的，就告诉客户以后再打。

这样的话找空闲的客服时间就是`O(n)`的，这个操作应该很频繁，可能很重要，所以考虑别的实现。自然想到的是优先队列，想到《算法导论》里用堆实现了个优先队列，但同时又想到了Unix的进程调度，它用了一个链表维护就绪进程，那我也可以用链表按总接待时间从小到大的顺序存储空闲的客服，链表实现比较简单，于是想采用链表实现。

我也不记得我是什么时候开始写的，但是前面的分析不是很久，很多都是边写，边发现，边构造的。

原想`int id`直接表示客服就够了，但是要记录客服接待时间，与其再设一个用`id`索引的 `vector<int>
worked_time`，还不如把`id`和`worked_time`都整到一个结构体里面去，这样又有了一个数据类型`Worker`，同时把`next`指针也放进去，用来实现空闲客服链表，应答客服的请求时
需要根据`id`判断他是否空闲，为了不从头扫一遍空闲链表，`Worker`再放一个域`bool is_free`。好有逻辑性！但实际`Worker`结构的域的添加顺序我已经不记得了。

类名就叫`PhoneAnswer`吧，原想把所有结构都放到这个类里，简单起见嘛，但是又觉得，如果我优先队列的实现想换一种的话就很麻烦，耦合的太严重了，这时我无耻的想到了《EffectiveC++》讲减少编译依存性的内容，就是头文件用指针，不用对象，这样就只用前向声明就行了。同时也想到那个`Pimpl Idiom`，这样`PhoneAnswer`就只有一个`PhoneAnswerImpl`指针了，所有实现都delegate给类
`PhoneAnswerImpl`。除了这个，更相关的是《SICP》讲的让程序与数据表示无关的内容，这样我就把优先队列又从`PhoneAnswerImpl`里分出来，单
独成为`PriorityQueue`类，同时提供一个约定的接口，如取队首，把某个客服加入队列，把某个客服移除队列（应答客服的离开请求）等，这样我下层的队列表示就可以变，可以用链表，
也可以用堆。（为了实现方便把链表实现相关的`next`指针整进`Worker`结构了，有点不理想）

接下来发现一个大麻烦：`PhoneAnswerImpl`的构造函数。`N`个`Worker`肯定得先分配好啊，直接声明为`vector`搞定。但是`PriorityQueue`怎么构造？为实现方面，用了一个头结点，不存任何有效内容，这个要先分配好，但是在构造函数里面`new`东西的话，失败怎么办，查了，`C++`可不是返回`NULL`，是抛出异常，还有资源泄漏这个讨厌的问题，以后还要记得`delete`，好烦啊，索性声明为`Worker m_head`，反正`Worker`是在`PriorityQueue`声明的，就不考虑什么编译依存性问题了，能不用指针就不用。但是它指向的内容呢？所有客服一开始都是空闲的，它指向第一个客服就行了，同时必须初始化空闲链表为所有客服，也就是把`m_all_worker`全连起来，同时把`m_all_worker[0]`的地址赋值给空闲链表头结点的`next`。有两种做法：

- 在`PhoneAnswerImpl`这样声明`PriorityQueue m_free_worker`，那`PriorityQueue`的初始化要在`PhoneAnswerImpl`构造函数里做，为了让`PhoneAnswerImpl`与`PriorityQueue`的下层数据表示无关，可以在`PriorityQueue`里定义`void init(vector<Worker>&all_worker)`，然后在`PhoneAnswerImpl`里调用它，同时把`m_all_worker`传进去，在`init`里要把所有客服链接起来，要修改`Worker`的`next`指针，所以传引用过去。这样的坏处就是在`PhoneAnswerImpl`必须`#incldue "PriorityQueue.hpp"`，好处是不用动态分配了。

- 在`PhoneAnswerImpl`这样声明`std::shared_ptr<PriorityQueue> m_free_worker`，这样只要有个前向声明`class PriorityQueue`就行了。我采用这种方法。
    
