---
layout: post
title: "电话应答系统模拟"
category: 
tags: []
---
{% include JB/setup %}
拿到题目，粗看了下，第二题用Ruby或其他脚本语言的就可以了，输入用shell通配*.log就行，然后脚本内按行处理，可能要用正则表达式。先做第一题。
###应答逻辑
实现起来如果直接一点的话，直接一个`bool worker[20]`表示20个客服的忙闲状态就够了，客服告诉系统他离开就置他为忙，但是不计时，如果他本身就是忙的，就拒绝他的离开请求；告诉系统他回来了就置他为闲；接待客户的话就直接从头开始遍历找第一个空闲的，置为忙，同时这个客服的接待时间加1，如果没有找到空闲的，就告诉客户以后再打。

这样的话找空闲的客服时间就是`O(n)`的，这个操作应该很频繁，可能很重要，所以考虑别的实现。自然想到的是优先队列，可以用堆，想到Unix的进程调度，用了个链表维护就绪进程，链表实现比较简单，因此用链表按总接待时间从小到大的顺序存储空闲的客服。

原想`int id`直接表示客服就够了，但是要记录客服接待时间，与其再设一个用`id`索引的 `vector<int>
worked_time`，还不如把`id`和`worked_time`都整到一个结构体里面去，这样又有了一个数据类型`Worker`，同时把`next`指针也放进去，用来实现空闲客服链表，应答客服的请求时
需要根据`id`判断他是否空闲，为了不从头扫一遍空闲链表，`Worker`再放一个域`bool is_free`。

类名就叫`PhoneAnswer`吧，原想把所有结构都放到这个类里，但是又觉得，如果优先队列的实现想换一种的话就很麻烦，耦合的太严重了，还有编译依存性问题，为减小编译依存性，采用`Pimpl Idiom`，这样`PhoneAnswer`就只有一个`PhoneAnswerImpl`指针了，所有实现都delegate给类
`PhoneAnswerImpl`，只要`PhoneAnswerImpl`接口不变，`PhoneAnswer`不需要重新编译，用`PhoneAnswer`的用户也不需要重新编译，只要链接新的`PhoneAnswerImpl`就行，如果编译成动态库，链接都省了。除了这个，更相关的是《SICP》讲的让程序与数据表示无关的内容，于是把优先队列又从`PhoneAnswerImpl`里分出来，单
独成为`PriorityQueue`类，同时提供一个约定的接口，如取队首，把某个客服加入队列，把某个客服移除队列（应答客服的离开请求）等，这样下层的队列表示就可以变，可以用链表，也可以用堆。为减小依存性，`PhoneAnswerImpl`使用`shared_ptr<PriorityQueue>`而不是`PriorityQueue`，优先队列不需要什么任何初始化，因为一开始就是空的。

接下来是已工作时间的上溢出问题。服务器一直不对工作时间清零的话它会一直累加，清零可以在服务器代码里用一个长度为24小时的计时器`alarm(60*60*24)`实现，只要在信号处理函数里把所有客服的已接待时间都清零就行。这应答系统有个不好的地方就是万一一个客服请求离开，然后再也不回来了话，系统没相应的处理。可以考虑把一天的总接待时间记录下来，然后跟薪水相关什么的，这个扩展还是在信号处理函数里做就行，在清零前`serialize`所有客服的接待时间就好了。系统对象PA（类型为`PhoneAnswer`）声明为全局的，并且提供`clear_time()`函数，这样信号处理函数直接调用这个函数就好了。用信号的话，注意不要调用`malloc`之类的不可重入的函数，同时服务器的系统调用可能被中断，中断的系统调用是不是重启跟操作系统相关，有移植性问题。另外，也可以用cron，定时，比如说每天0点，给服务器发送一个信号`SIGUSR1`，服务器在`SIGUSR1`的处理函数做清零操作。还有一种做法。因为客服的客户端在客服下班后就会断开连接，这时服务器把客服从空闲链表中移除，同时清零`worked_time`，当客服在第二天重新连接时，再把客服加到空闲链表。这样的话，那么服务器的初始化就应该把所有客服初始化为忙的，空闲链表为空，当客服连接时才把它加到空闲链表。可是，如果客服只是电脑死机了，那么系统会认为他下班后再上班，把他的`worked_time`清零，那么他在当天就会忙死。如果增加按钮让客服可以发送表示上班，下班的信息，那么可以在上班信息到来时清零，可是可能有的客服为了多接电话（赚多点钱），不停的按那个按钮，使得他老是在优先队列的前面，也有可能客服不想那么累，但不小心按了那个按钮，那他当天也悲剧了。让客服老是在上班的时候和下班的时候都要按按钮也让客服很不爽。

###客户服务器通信
总共20个客服，意味着并发连接只有40个，考虑用`select`实现服务器，如果以后系统扩展了，再考虑换为`kqueue`或`epoll`。有时间也可以用线程或进程实现看看。

####正常情况
系统正常情况时应该是这样的：开启服务器，所有客服连接服务器。分机是固定不变的，总机能够区分分机和客户的连接，因此模拟系统也应该可以区分，这可以通过固定客服IP模拟，客服的IP服务器事先知道，但是为了调试和模拟方便，最好能在同一台机器运行服务器端和客户端，这时所有客户端IP地址都是`127.0.0.1`，为简单起见，前20个连接默认为客服，且客服ID依次为0-19。对于前20个连接，把客服置为闲，以后的连接，都是客户的连接，当客户连接时，因为他意图只有一个，所以直接调用`answer_call`去找空闲客服，然后把结果回复给客户，如果没有空闲的，直接关闭与客户的连接。

如果有空闲的，那么客户就可以发送信息了，信息由服务器中转，所以服务器必须能够知道接待客户的客服的`socket `描述子`workerfd`，而客服也会向客户发送信息，所以系统也必须知道客服接待的客户的描述子`clientfd`，但是系统对象`PA`的`answer_call`返回的是客服的id`workerid`，系统应该还有张表，是客服的固定IP和`workerid`的对应表。如果用IP索引，那么就得用`unordered_map`什么的，太复杂，于是采用`workerid`索引的，那么这个表就可以实现为长度为20的int数组。那么只要再维护两张表，`clientfd[]`和`workerfd[]`，均由`workerid`索引，就可以实现这种对应关系了。这样每次客户发送信息，需要一个映射`clientfd -> workerfd`，那么需要遍历`clientfd[]`，找到相等时的索引`workerid`，那么`workerfd = workerfd[workerid]`，这样的话复杂度`O(n)`，这就意味着其实空闲客服列表也不一定要用`PriorityQueue`，也可以遍历一遍所有客服列表，查看第一个空闲的。想来内存分配也有个这样策略，叫做首次适应（First Fit）。而且像内存啊，就绪进程啊，都可能很多，不像这个系统，只有20个客服，遍历一遍也不太有所谓。不过如果以后公司扩大，为减少查找时间，可以用5个`unordered_map`：

- 表1：`客服IP -> workerid`。这张表是不会变的，这张表可以判断进来的连接是否是客服，顺便存了下`workerid`。
- 表2：`workerid -> workerfd`。每连接一个客服，先查表1，得到`workerid`，然后存下对应的描述子`workerfd`。这张表需要是因为系统在`answer_call`后要建立`clientfd`和`workerfd`的对应关系，这样客服和客户才能互相通话，`clientfd`已知，但是`answer_call`返回的是`workerid`，所以必须有这么一张表。
- 表3：`workerfd -> workerid` 。用于客服请求离开和请求回来。
- 表4：`clientfd -> workerfd`。用于客户向客服发消息。
- 表5：`workerfd -> clientfd`。用户客服向客户发消息。

经过一段时间的通话，客服会请求通话完毕或者客户挂机，这时服务器会关闭与客户的连接，而不断开客服的连接，只是把客服放到空闲列表去。一分钟的通话时限可以由客服自己把握。
####异常情况

- 客服断开连接。因为这是个模拟电话的系统，电话的话，分机和总机是一直连着的， 那也就意味着，客服和服务器的连接永远不会断，除非出故障了。所以这时系统应该报告故障，同时把那个客服置为忙。服务器可以有个功能，显示当前已连接的客服，这样就可以知道哪些分机坏了。
- 客服离开，但没有事先请求离开。然后他被分配到去接待某个客户。客户发了消息，就会一直得不到回复。这个异常可以不处理，因为客户是知道客服id的，他可以投诉这个客服。
- 拒绝服务攻击。因为这是个电话模拟系统，所以跟网络里的攻击还不太一样。使用select后，当一个套接字是可以读了，服务器就去处理那个套接字了，但是你不知道该读多少字节，可以用换行符表示一次读的截止，如果是阻塞读，那么就可能有恶意用户发送一个字节，然后去睡眠，那么服务器就阻塞在`readline`里。在电话模拟系统里，我们用`readline`模拟客服说了一句话或者客户说了一句话。假设一个恶意用户，发起连接，那么系统会分配一个客服给他，假设他挂机，系统会收回那个客服，假设他不挂机，客服发现客户长时间不说话，他可以挂机，即发送`worker_back`消息。这时系统可以把`clientfd`和`workerfd`socket对从表4，5中删除。恶意用户可以不停的发起连接，然后直接挂机。那么系统会不断的分配，收回。但是系统不会阻塞，客服不会因为恶意用户而一直忙，那么假设恶意用户不直接挂机，在那待一会。
    --      如果电话收费，那么恶意用户会吃亏很多，如果利益小于这个收费，就没有恶意用户。
    -- 如果不收费，那么就相当于他和正常用户抢连接，的确挺麻烦的，到时可能客服接到的都是不说话的电话，然后客服挂机，再然后又接到不说话的电话，客服好烦，正常用户也会连不上。不过电话不像网络，可以用机器人发包。必须人手拨。但是网络电话起来了就不好说了。

    不管怎样，这个系统可以模拟电话系统里的拒绝服务攻击，但是服务器暂时还没有应对措施。
    
       
###服务器和客户端的具体实现
下面说明服务器和客服客户的客户端的具体实现。
####服务器
服务器总共要处理4种事件，用接收到消息的第一个字节就可以表示。

- 0：worker leave。客服闲变忙。客服要求离开。
- 1：worker back。客服忙变闲。客服要求返回或者客服表示通话完毕。
- 2：worker send。客服发送消息。
- 3：client send。客户发送消息。

还有两种没有消息的事件。

- 客户断开连接，这个由从客户套接字`Read`到0检测出。系统调用`worker_back`把服务它的客服放回空闲列表。
- 客服断开连接，由客服套接字`Read`到0检测出。

最后一个要做的事是工作时间清零操作，这个决定用`alarm(60*60*24)`实现。
####客服客户端
从标准输入得到客服的输入，有3种事件。

- 0：worker leave。客服要求离开。
- 1：worker back。客服要求返回或者客服表示通话完毕。
- 2：worker send。客服发送信息。

与服务器的交互有

- 把客服的离开、返回、通话完毕的消息转发给服务器。
- 把客服给客户的消息发送给服务器，以及把客户经由服务器发送的消息显示给客服。
####用户客户端
连接服务器，接收服务器的消息，如果消息表示没有空闲客服，则显示系统忙，然后断开连接，过段时间再去连接。如果消息表示有空闲客服则把标准输入和套接字加入`select`的监听事件中去。同时显示给用户表示通话请求已被接收，并告诉他可以输入消息开始通话了。