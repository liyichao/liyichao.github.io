---
layout: post
title: "kids多线程实现"
category:
tags: []
---
{% include JB/setup %}

###kids

kids是一个消息订阅与发布系统。服从redis协议，主要功能和redis的pub/sub
一致。网络IO的代码完全从redis照搬。整个程序逻辑是事件驱动，使用redis的
`ae.c`事件驱动库。注册监听套接字`conn_notify_receive_fd_`的读事件
`NewConnectionHandler`，连接进来，读事件被调用，注册客户套接字读事件
`ReadRequest`。

在`ReadRequest`中，需要对读到的字节进行`ParseRequestBuffer`，该函数相
当精髓。用几个变量表示了解析的状态：`argc_`，`argv_`，`cur_arglen_`。

解析到一个完整的命令则查找命令表，并调用相应的命令，对于kids，主要的只
有两个命令publish和subscribe。这两个命令主要有四个结构实现：

    class Worker {
        std::list<Pattern*> pubsub_patterns_;
        std::unordered_map<sds, std::list<Client*> > clients_by_topic_;
    };

    class Client {
        std::unordered_set<sds> sub_topics_;
        std::unordered_set<sds> sub_patterns_;
    };

###多线程实现

一个主线程，负责accept连接，一个信号线程，负责处理信号，多个工作线程，
负责处理客户的pub/sub请求。

主线程屏蔽了常见信号`SIGINT`，`SIGTERM`，`SIGPIPE`，`SIGUSR1`（用于旋
转日志）。信号线程调用`sigwait`等待信号。

采用一个全局队列保存消息。publish一条消息，工作线程把该消息放到全局队
列，同时通知其他工作线程。通知采用`socketpair`生成的管道。与之相关的结
构是：

    class Worker {
         const int num_workers_;
         int* msg_wait_to_notify_;
         int* msg_notify_send_fd_;
         int* msg_notify_receive_fd_;
    };

每个线程，为其他工作线程开放了单独的管道。这点值得商榷。可以只开一个管
道，其他所有线程共享这个管道，这时就得考虑并发`write`一个套接字的线程
安全问题了。另外，新连接到来的消息也可以考虑用同一管道通知。通知只需要
写一个字节就行。新连接写入‘c'，新消息写入'm'，在读管道时在调用相应的处
理函数。

必须考虑的问题是管道缓冲区满了怎么办。目前的做法是用
`msg_wait_to_notify_`保存暂时没通知到位的消息数量，在`Worker::Cron`里
会尝试去完成这些通知。也可以只通知一次，工作线程接收到通知后，把全局队
列里所有新消息都消费完毕，而不是一次通知，只消费一个。这样可能会使订阅
客户的响应缓冲区满，因为在一次事件里publish了好多消息。另外，也必须处
理接到通知，却没新消息的情况，因为新消息可能被上一次通知给提前消费掉了。
这样就可以不管缓冲区满的情况了。

另外，可以模仿信号里的做法。每个工作线程都有一个变量has\_message表示有
消息，publish消息时，如果has\_message为0则通知工作线程，为1表示已通知，
就不用`write`了。在工作线程处理新消息的事件里，清has\_message。同时一
直读全局队列读到尾部。

采用主线程accept连接，然后把套接字传给工作线程，是一种负载均衡办法。另
外也可以工作线程都注册监听套接字到自己的EventLoop ，这样的话当新连接到
来时所有线程都会被惊醒，然后只有一个线程能accept成功。也可以各工作线程
来抢一个锁，抢到的注册读事件，在读事件里，可以只accept一次，也可以
accept直到没有新连接。

假设只accept一次，那么队列里的新连接就得等到下一次某个线程抢到监听权利，
注册事件，然后轮到监听套接字的处理。

accept多次可能使得一个线程连接数过多，所以也需要限制，当该线程连接数过
多时不再去accept了。在处理事件时，也要优先处理监听套接字的事件，以尽快
把accept的权利释放出来，让闲的工作线程能够接受连接。

必须保证每个套接字得到公平待遇。所以`ReadRequest`，`SendReply`读写字节
数都有限制。不过工作线程新连接事件可以考虑在一次事件里把
`conn_queue_`队列里所有连接都收了，因为只是注册下连接的读事件嘛，时间
花费不大。主线程的accept事件也可以循环调用accept直到没有新连接为止。不
过，所减少的时间也仅仅是两次事件调用的延迟，而增加的是`ReadRequest`和
`Worker::GetNewConnection`两个事件的不一致的处理方式带来的复杂性。


